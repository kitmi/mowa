'use strict';const path=require('path');const util=require('util');const Util=require('./util.js');const AppModule=require('./appmodule.js');const OolongRuntime=require('./oolong/runtime');const pkg=require('../package.json');const Commons=Util.Literal;process.on('uncaughtException',e=>{console.error('UncaughtException: '+e.stack);process.exit(1)});class MowaServer extends AppModule{constructor(name,options){if(typeof options==='undefined'){if(typeof name==='undefined'){name='server'}else if(util.isObject(name)){options=name;name='server'}}if(options&&options.oneAppMode&&!options.etcPath){options.etcPath=path.resolve(__dirname,'..','conf','oneAppMode')}super(null,name,null,options);this._httpServers=[];this._pendingHttpServer=0}start(extraFeatures){this.emit('starting',this);this.log('info',`Starting mowa server v.${pkg.version} ...`);this.loadMiddlewareFiles(path.resolve(__dirname,Commons.MIDDLEWARES_PATH));return super.start(extraFeatures).then(()=>{if(this._pendingHttpServer>0){this.once('allHttpReady',()=>{this.emit('started',this)})}else{this.emit('started',this)}return this}).catch(error=>{if(this.env==='development'&&util.isError(error)){console.error(error.stack)}this.log('error','Failed to start server!');process.exit(1)})}stop(){this.emit('stopping',this);return super.stop().then(()=>{let promises=this._httpServers.reverse().map(s=>new Promise((resolve,reject)=>{let port=s.address().port;s.close(err=>{if(err)return reject(err);this.log('info',`The http server listening on port [${port}] is stopped.`);resolve()})}));return Promise.all(promises).then(()=>{this._httpServers=[];this.emit('stopped',this)})})}addHttpServer(appModule,httpServer){this._httpServers.push(httpServer);this._pendingHttpServer++;appModule.once('httpReady',()=>{this._pendingHttpServer--;if(this._pendingHttpServer==0){this.emit('allHttpReady')}})}}MowaServer.Util=Util;MowaServer.OolongRuntime=OolongRuntime;module.exports=MowaServer;