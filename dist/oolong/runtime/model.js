'use strict';const Mowa=require('../../server.js'),Util=Mowa.Util,_=Util._,Errors=require('./errors.js'),{ModelValidationError,ModelOperationError}=Errors,Generators=require('./generators.js'),Validators=require('./validators.js');let Model=class Model{constructor(rawData){this.isNew=true;if(rawData){this.data=Model._filterNullValues(rawData)}this.appModule=this.db.appModule}fromDb(data){this.isNew=false;this.pendingUpdate=new Set;this.oldData=data;this.data=new Proxy(Object.assign({},data),{set:(obj,prop,value)=>{if(!(prop in this.meta.fields))return true;obj[prop]=value;if(this.oldData[prop]!=value){this.pendingUpdate.add(prop)}else{this.pendingUpdate.delete(prop)}return true}});return this}get db(){return this.constructor.db}get meta(){return this.constructor.meta}async save(){if(this.isNew){let context=await this._preCreate();if(0<context.errors.length){throw new ModelValidationError(context.errors)}if(!_.isEmpty(this.meta.atLeastOneNotNull)){this.meta.atLeastOneNotNull.forEach(group=>{if(_.every(group,fieldName=>_.isNil(context.latest[fieldName]))){throw new ModelValidationError({fields:group.map(f=>this.meta.fields[f]),message:'At least one of these fields should not be null.'})}})}return this._doCreate(context)}else{let context=await this._preUpdate();if(0<context.errors.length){throw new ModelValidationError(context.errors)}if(!_.isEmpty(this.meta.atLeastOneNotNull)){this.meta.atLeastOneNotNull.forEach(group=>{if(_.every(group,fieldName=>fieldName in context.latest&&_.isNil(context.latest[fieldName])||!(fieldName in context.latest)&&_.isNil(context.existing[fieldName]))){throw new ModelValidationError({fields:group.map(f=>this.meta.fields[f]),message:'At least one of these fields should not be null.'})}})}return this._doUpdate(context)}}async _preCreate(){return this.constructor._rawDataPreProcess({raw:this.data},true)}async _preUpdate(){let raw=_.pick(this.data,Array.from(this.pendingUpdate));return this.constructor._rawDataPreProcess({existing:this.oldData,raw,updating:this.pendingUpdate})}static async _rawDataPreProcess(context,isNew=false){let meta=this.meta,fields=meta.fields,{raw}=context,errors=[],latest={};context.errors=errors;context.latest=latest;for(let fieldName in fields){let fieldMeta=fields[fieldName];if(fieldName in raw){if(fieldMeta.readOnly){throw new ModelValidationError({field:fieldMeta,message:'Read-only field is not allowed to be set by manual input.'})}else if(!isNew&&fieldMeta.fixedValue){if(!_.isNil(context.existing[fieldName])){throw new ModelValidationError({field:fieldMeta,message:'Write-once-only field is not allowed to be update once it was set.'})}}let sanitizeState=Validators.$sanitize(fieldMeta,raw[fieldName]);if(sanitizeState.error){errors.push(sanitizeState.error);return context}latest[fieldName]=sanitizeState.sanitized;continue}if(isNew){if(!fieldMeta.defaultByDb){if('default'in fieldMeta){latest[fieldName]=fieldMeta.default}else if(fieldMeta.auto){latest[fieldName]=Generators.generate(fieldMeta)}else if(!fieldMeta.optional){errors.push({field:fieldMeta,message:'Missing required field.'});return context}}}else{if(fieldMeta.fixedValue&&!_.isNil(context.existing[fieldName])){continue}if(fieldMeta.forceUpdate){if(fieldMeta.updateByDb){continue}context.updating.add(fieldName)}}}return context}static _filterNullValues(condition){let result={};_.forOwn(condition,(value,key)=>{if(!_.isNil(value)){result[key]=value}});return result}static async findOne(condition){if(!_.isPlainObject(condition)){if(_.isNil(condition)){throw new Mowa.Error.InvalidRequest('Argument is null.')}condition={[this.meta.keyField]:condition}}else{let containsUniqueKey=_.find(this.meta.uniqueKeys,fields=>{let containsAll=true;fields.forEach(f=>{if(!(f in condition))containsAll=false});return containsAll});if(!containsUniqueKey){throw new Mowa.Error.InvalidArgument('"findOne()" requires condition with unique keys.')}condition=this._filterNullValues(condition)}let fields=Object.keys(this.meta.fields),record=await this._doFindOne(_.pick(condition,fields));if(!record)return undefined;let Model=this,model=new Model;return model.fromDb(record)}static async find(condition,fetchArray=false){if(!_.isPlainObject(condition)){throw new Mowa.Error.InvalidArgument('"find()" requires condition to be plain object.')}let fields=Object.keys(this.meta.fields),records=await this._doFind(_.pick(Model._filterNullValues(condition),fields));if(!records)return undefined;if(fetchArray)return records;return records.map(row=>{let model=new this.constructor;return model.fromDb(row)})}static async removeOne(condition){if(!_.isPlainObject(condition)){if(_.isNil(condition)){throw new Mowa.Error.InvalidRequest('Argument is null.')}condition={[this.meta.keyField]:condition}}else{let containsUniqueKey=_.find(this.meta.uniqueKeys,fields=>{let containsAll=true;fields.forEach(f=>{if(!(f in condition))containsAll=false});return containsAll});if(!containsUniqueKey){throw new Mowa.Error.InvalidArgument('"removeOne()" requires condition with unique keys.')}condition=this._filterNullValues(condition)}return await this._doRemoveOne(condition)}};module.exports=Model;